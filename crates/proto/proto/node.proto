syntax = "proto3";

package node;

// ============================================================================
// Node-to-Node Services
// ============================================================================
// This file defines protocols for communication between nodes,
// such as snapshot transfer, data migration, and other operational operations.
// These are separate from Raft consensus protocols (defined in
// raft/proto/pb.proto).

// ============================================================================
// Snapshot Transfer Service
// ============================================================================
// Used for transferring snapshots from Leader to Follower.

/// Snapshot transfer service
service SnapshotService {
  /// Pull snapshot data (server streaming)
  /// Follower actively pulls snapshot data from Leader after receiving
  /// InstallSnapshotRequest This allows Follower to control the transfer rate
  /// and support resume from offset
  rpc PullSnapshotData(PullSnapshotDataRequest)
      returns (stream PullSnapshotDataResponse);

  /// Query transfer progress
  rpc GetTransferProgress(GetTransferProgressRequest)
      returns (GetTransferProgressResponse);
}

/// Pull snapshot data request
/// Sent by Follower to Leader to request snapshot data chunks
message PullSnapshotDataRequest {
  /// Raft group ID (shard ID in multi-raft context)
  string raft_group_id = 1;
  /// Snapshot index (from InstallSnapshotRequest.last_included_index)
  uint64 snapshot_index = 2;
  /// Snapshot term (from InstallSnapshotRequest.last_included_term)
  uint64 snapshot_term = 3;
  /// Snapshot request ID (from InstallSnapshotRequest.snapshot_request_id)
  uint64 snapshot_request_id = 4;
  /// Starting byte offset in the snapshot data stream (for resume/retry, 0 for first request)
  /// This is a byte-level offset, not a chunk index. Leader will read from this byte position.
  uint64 offset = 5;
  /// Maximum chunk size in bytes (hint for Leader, typically 1MB)
  uint32 max_chunk_size = 6;
  /// Transfer ID (unique identifier for this transfer, generated by Follower)
  string transfer_id = 7;
}

/// Pull snapshot data response (one chunk)
/// Streamed from Leader to Follower
message PullSnapshotDataResponse {
  /// Transfer ID (matches request)
  string transfer_id = 1;
  /// Chunk data (typically 1MB per chunk)
  bytes chunk_data = 2;
  /// Starting byte offset of this chunk in the snapshot data stream
  /// This indicates where this chunk starts in the overall snapshot byte stream
  uint64 offset = 3;
  /// Chunk size in bytes
  uint32 chunk_size = 4;
  /// Whether this is the last chunk
  bool is_last_chunk = 5;
  /// Total snapshot size in bytes (only in first chunk)
  uint64 total_size = 6;
  /// Chunk checksum (CRC32 or SHA256)
  bytes checksum = 7;
  /// Error message (if failed, stream will end)
  string error_message = 8;
}

/// Get transfer progress request
message GetTransferProgressRequest {
  /// Transfer ID
  string transfer_id = 1;
}

/// Get transfer progress response
message GetTransferProgressResponse {
  /// Transfer status
  TransferStatus status = 1;
  /// Total bytes received
  uint64 received_bytes = 2;
  /// Total bytes expected
  uint64 total_bytes = 3;
  /// Number of chunks received
  uint32 received_chunks = 4;
  /// Total number of chunks
  uint32 total_chunks = 5;
  /// Error message (if failed)
  string error_message = 6;
}

/// Transfer status
enum TransferStatus {
  TRANSFER_STATUS_UNSPECIFIED = 0;
  /// Transfer in progress
  IN_PROGRESS = 1;
  /// Transfer completed successfully
  COMPLETED = 2;
  /// Transfer failed
  FAILED = 3;
  /// Transfer not found
  NOT_FOUND = 4;
}

// ============================================================================
// Data Migration Service
// ============================================================================
// Used for migrating data between nodes during rebalancing or node removal.

/// Data migration service
service MigrationService {
  /// Start data migration
  rpc StartMigration(StartMigrationRequest) returns (StartMigrationResponse);

  /// Transfer migration data (streaming)
  rpc TransferMigrationData(stream MigrationDataChunk)
      returns (MigrationDataResponse);

  /// Complete migration
  rpc CompleteMigration(CompleteMigrationRequest)
      returns (CompleteMigrationResponse);

  /// Cancel migration
  rpc CancelMigration(CancelMigrationRequest) returns (CancelMigrationResponse);
}

/// Start migration request
message StartMigrationRequest {
  /// Migration task ID
  string task_id = 1;
  /// Source shard ID
  string source_shard_id = 2;
  /// Target node ID
  string target_node_id = 3;
  /// Slot range to migrate
  SlotRange slot_range = 4;
}

/// Slot range
message SlotRange {
  /// Start slot (inclusive)
  uint32 start_slot = 1;
  /// End slot (exclusive)
  uint32 end_slot = 2;
}

/// Start migration response
message StartMigrationResponse {
  /// Whether migration was started successfully
  bool success = 1;
  /// Error message (if failed)
  string error_message = 2;
}

/// Migration data chunk
message MigrationDataChunk {
  /// Migration task ID
  string task_id = 1;
  /// Chunk index
  uint32 chunk_index = 2;
  /// Whether this is the last chunk
  bool is_last_chunk = 3;
  /// Chunk data
  bytes data = 4;
  /// Chunk checksum
  bytes checksum = 5;
}

/// Migration data response
message MigrationDataResponse {
  /// Whether chunk was received successfully
  bool success = 1;
  /// Error message (if failed)
  string error_message = 2;
  /// Total bytes received
  uint64 received_bytes = 3;
}

/// Complete migration request
message CompleteMigrationRequest {
  /// Migration task ID
  string task_id = 1;
}

/// Complete migration response
message CompleteMigrationResponse {
  /// Whether migration was completed successfully
  bool success = 1;
  /// Error message (if failed)
  string error_message = 2;
}

/// Cancel migration request
message CancelMigrationRequest {
  /// Migration task ID
  string task_id = 1;
}

/// Cancel migration response
message CancelMigrationResponse {
  /// Whether migration was cancelled successfully
  bool success = 1;
  /// Error message (if failed)
  string error_message = 2;
}

// ============================================================================
// Health Check Service
// ============================================================================
// Used for health checks and status queries between nodes.

/// Health check service
service HealthService {
  /// Health check
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);

  /// Get node status
  rpc GetNodeStatus(GetNodeStatusRequest) returns (GetNodeStatusResponse);
}

/// Health check request
message HealthCheckRequest {
  /// Optional: specific service to check
  string service = 1;
}

/// Health check response
message HealthCheckResponse {
  /// Health status
  HealthStatus status = 1;
  /// Optional message
  string message = 2;
}

/// Health status
enum HealthStatus {
  HEALTH_STATUS_UNSPECIFIED = 0;
  /// Healthy
  HEALTHY = 1;
  /// Degraded (some issues but still operational)
  DEGRADED = 2;
  /// Unhealthy
  UNHEALTHY = 3;
}

/// Get node status request
message GetNodeStatusRequest {
  // Empty for now, can be extended
}

/// Get node status response
message GetNodeStatusResponse {
  /// Node ID
  string node_id = 1;
  /// Node status
  NodeStatus status = 2;
  /// Number of shards managed
  uint32 shard_count = 3;
  /// Total memory usage (bytes)
  uint64 memory_usage = 4;
  /// CPU usage percentage
  double cpu_usage = 5;
}

/// Node status
enum NodeStatus {
  NODE_STATUS_UNSPECIFIED = 0;
  /// Node is running normally
  RUNNING = 1;
  /// Node is starting up
  STARTING = 2;
  /// Node is shutting down
  SHUTTING_DOWN = 3;
  /// Node is in maintenance mode
  MAINTENANCE = 4;
}
